// AUTOGENERATED CODE
//
// Do not make changes directly to this (.cs) file.
// Change "LDI +                    .tt" instead.

namespace Konamiman.Z80dotNet
{
    public partial class Z80InstructionExecutor
    {
        /// <summary>
        /// The LDI instruction.
        /// </summary>
        private byte LDI()
        {
            FetchFinished();

            var sourceAddress = Registers.HL;
            var destAddress = Registers.DE;
            var counter = Registers.BC;
            var value = processorAgent.ReadFromMemory((ushort)sourceAddress);
            processorAgent.WriteToMemory((ushort)destAddress, value);

            Registers.HL = (short)(sourceAddress + 1);
            Registers.DE = (short)(destAddress + 1);
            counter--;
            Registers.BC = counter;

            Registers.HF = 0;
            Registers.NF = 0;
            Registers.PF = counter != 0;

            var valuePlusA = (byte)(value + Registers.A);
            Registers.Flag3 = valuePlusA.GetBit(3);
            Registers.Flag5 = valuePlusA.GetBit(1);

            return 16;
        }

        /// <summary>
        /// The LDD instruction.
        /// </summary>
        private byte LDD()
        {
            FetchFinished();

            var sourceAddress = Registers.HL;
            var destAddress = Registers.DE;
            var counter = Registers.BC;
            var value = processorAgent.ReadFromMemory((ushort)sourceAddress);
            processorAgent.WriteToMemory((ushort)destAddress, value);

            Registers.HL = (short)(sourceAddress - 1);
            Registers.DE = (short)(destAddress - 1);
            counter--;
            Registers.BC = counter;

            Registers.HF = 0;
            Registers.NF = 0;
            Registers.PF = counter != 0;

            var valuePlusA = (byte)(value + Registers.A);
            Registers.Flag3 = valuePlusA.GetBit(3);
            Registers.Flag5 = valuePlusA.GetBit(1);

            return 16;
        }

        /// <summary>
        /// The LDIR instruction.
        /// </summary>
        private byte LDIR()
        {
            FetchFinished();

            var sourceAddress = Registers.HL;
            var destAddress = Registers.DE;
            var counter = Registers.BC;
            var value = processorAgent.ReadFromMemory((ushort)sourceAddress);
            processorAgent.WriteToMemory((ushort)destAddress, value);

            Registers.HL = (short)(sourceAddress + 1);
            Registers.DE = (short)(destAddress + 1);
            counter--;
            Registers.BC = counter;

            Registers.HF = 0;
            Registers.NF = 0;
            Registers.PF = counter != 0;

            var valuePlusA = (byte)(value + Registers.A);
            Registers.Flag3 = valuePlusA.GetBit(3);
            Registers.Flag5 = valuePlusA.GetBit(1);

            if (counter != 0)
            {
                Registers.PC = (ushort)(Registers.PC - 2);
                return 21;
            }

            return 16;
        }

        /// <summary>
        /// The LDDR instruction.
        /// </summary>
        private byte LDDR()
        {
            FetchFinished();

            var sourceAddress = Registers.HL;
            var destAddress = Registers.DE;
            var counter = Registers.BC;
            var value = processorAgent.ReadFromMemory((ushort)sourceAddress);
            processorAgent.WriteToMemory((ushort)destAddress, value);

            Registers.HL = (short)(sourceAddress - 1);
            Registers.DE = (short)(destAddress - 1);
            counter--;
            Registers.BC = counter;

            Registers.HF = 0;
            Registers.NF = 0;
            Registers.PF = counter != 0;

            var valuePlusA = (byte)(value + Registers.A);
            Registers.Flag3 = valuePlusA.GetBit(3);
            Registers.Flag5 = valuePlusA.GetBit(1);

            if (counter != 0)
            {
                Registers.PC = (ushort)(Registers.PC - 2);
                return 21;
            }

            return 16;
        }
    }
}