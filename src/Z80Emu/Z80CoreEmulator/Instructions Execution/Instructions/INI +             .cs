// AUTOGENERATED CODE
//
// Do not make changes directly to this (.cs) file.
// Change "INI +             .tt" instead.

namespace Konamiman.Z80dotNet
{
    public partial class Z80InstructionExecutor
    {
        /// <summary>
        /// The INI instruction.
        /// </summary>
        private byte INI()
        {
            FetchFinished();

            var portNumber = Registers.C;
            var address = Registers.HL;
            var value = processorAgent.ReadFromPort(portNumber);
            processorAgent.WriteToMemory((ushort)address, value);

            Registers.HL++;
            var counter = Registers.B;
            counter = (byte)(counter - 1);
            Registers.B = counter;
            Registers.ZF = counter == 0;
            Registers.NF = 1;
            Registers.SF = counter.GetBit(7);
            SetFlags3and5From(counter);

            return 16;
        }

        private byte ILLEGAL()
        {
            throw new NotImplementedException("Illegal instruction");
        }

        /// <summary>
        /// The IND instruction.
        /// </summary>
        private byte IND()
        {
            FetchFinished();

            var portNumber = Registers.C;
            var address = Registers.HL;
            var value = processorAgent.ReadFromPort(portNumber);
            processorAgent.WriteToMemory((ushort)address, value);

            Registers.HL--;
            var counter = Registers.B;
            counter = (byte)(counter - 1);
            Registers.B = counter;
            Registers.ZF = counter == 0;
            Registers.NF = 1;
            Registers.SF = counter.GetBit(7);
            SetFlags3and5From(counter);

            return 16;
        }

        /// <summary>
        /// The INIR instruction.
        /// </summary>
        private byte INIR()
        {
            FetchFinished();

            var portNumber = Registers.C;
            var address = Registers.HL;
            var value = processorAgent.ReadFromPort(portNumber);
            processorAgent.WriteToMemory((ushort)address, value);

            Registers.HL++;
            var counter = Registers.B;
            counter = (byte)(counter - 1);
            Registers.B = counter;
            Registers.ZF = counter == 0;
            Registers.NF = 1;
            Registers.SF = counter.GetBit(7);
            SetFlags3and5From(counter);

            if (counter != 0)
            {
                Registers.PC = (ushort)(Registers.PC - 2);
                return 21;
            }

            return 16;
        }

        /// <summary>
        /// The INDR instruction.
        /// </summary>
        private byte INDR()
        {
            FetchFinished();

            var portNumber = Registers.C;
            var address = Registers.HL;
            var value = processorAgent.ReadFromPort(portNumber);
            processorAgent.WriteToMemory((ushort)address, value);

            Registers.HL--;
            var counter = Registers.B;
            counter = (byte)(counter - 1);
            Registers.B = counter;
            Registers.ZF = counter == 0;
            Registers.NF = 1;
            Registers.SF = counter.GetBit(7);
            SetFlags3and5From(counter);

            if (counter != 0)
            {
                Registers.PC = (ushort)(Registers.PC - 2);
                return 21;
            }

            return 16;
        }

        /// <summary>
        /// The OUTI instruction.
        /// </summary>
        private byte OUTI()
        {
            FetchFinished();

            var portNumber = Registers.C;
            var address = Registers.HL;
            var value = processorAgent.ReadFromMemory((ushort)address);
            processorAgent.WriteToPort(portNumber, value);

            Registers.HL++;
            var counter = Registers.B;
            counter = (byte)(counter - 1);
            Registers.B = counter;
            Registers.ZF = counter == 0;
            Registers.NF = 1;
            Registers.SF = counter.GetBit(7);
            SetFlags3and5From(counter);

            return 16;
        }

        /// <summary>
        /// The OUTD instruction.
        /// </summary>
        private byte OUTD()
        {
            FetchFinished();

            var portNumber = Registers.C;
            var address = Registers.HL;
            var value = processorAgent.ReadFromMemory((ushort)address);
            processorAgent.WriteToPort(portNumber, value);

            Registers.HL--;
            var counter = Registers.B;
            counter = (byte)(counter - 1);
            Registers.B = counter;
            Registers.ZF = counter == 0;
            Registers.NF = 1;
            Registers.SF = counter.GetBit(7);
            SetFlags3and5From(counter);

            return 16;
        }

        /// <summary>
        /// The OTIR instruction.
        /// </summary>
        private byte OTIR()
        {
            FetchFinished();

            var portNumber = Registers.C;
            var address = Registers.HL;
            var value = processorAgent.ReadFromMemory((ushort)address);
            processorAgent.WriteToPort(portNumber, value);

            Registers.HL++;
            var counter = Registers.B;
            counter = (byte)(counter - 1);
            Registers.B = counter;
            Registers.ZF = counter == 0;
            Registers.NF = 1;
            Registers.SF = counter.GetBit(7);
            SetFlags3and5From(counter);

            if (counter != 0)
            {
                Registers.PC = (ushort)(Registers.PC - 2);
                return 21;
            }

            return 16;
        }

        /// <summary>
        /// The OTDR instruction.
        /// </summary>
        private byte OTDR()
        {
            FetchFinished();

            var portNumber = Registers.C;
            var address = Registers.HL;
            var value = processorAgent.ReadFromMemory((ushort)address);
            processorAgent.WriteToPort(portNumber, value);

            Registers.HL--;
            var counter = Registers.B;
            counter = (byte)(counter - 1);
            Registers.B = counter;
            Registers.ZF = counter == 0;
            Registers.NF = 1;
            Registers.SF = counter.GetBit(7);
            SetFlags3and5From(counter);

            if (counter != 0)
            {
                Registers.PC = (ushort)(Registers.PC - 2);
                return 21;
            }

            return 16;
        }
    }
}