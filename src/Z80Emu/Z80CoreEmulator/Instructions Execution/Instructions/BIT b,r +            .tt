<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="_Utils.t4"#>
<#@ output extension=".cs" #>
<#AutoGeneratedCodeWarning(); #>

using System;

namespace Konamiman.Z80dotNet
{
    public partial class Z80InstructionExecutor
    {
<#  foreach (var reg in new[] {"A", "B", "C", "D", "E", "H", "L", "(HL)", "(IX+n)", "(IY+n)"}) {
    for(var bit=0; bit<=7; bit++) {
        var isMemHL = (reg == "(HL)");
		var isMemIndex = (reg.StartsWith("(I"));
        var instrName = String.Format("BIT {0},{1}", bit, reg);
        var methodName = String.Format("BIT_{0}_{1}", bit, MethodRegPartName(reg)); #>
		/// <summary>
        /// The <#=instrName #> instruction
        /// </summary>
        byte <#=methodName #>(<#=isMemIndex ? "byte offset" : "" #>)
        {
            FetchFinished();

<# GetOldValueFromRegOrMem(reg); #>
        var bitValue = oldValue.GetBit(<#=bit#>);
            Registers.ZF = Registers.PF = ~bitValue;
            Registers.SF = <#= bit == 7 ? "bitValue" : "0"#>;
            Registers.HF = 1;
            Registers.NF = 0;

			return <#=isMemHL ? 12 : isMemIndex ? 20 : 8 #>;
        }

<# }} #>
	}
}
